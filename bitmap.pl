#!/usr/bin/perl -w

$outfile=shift;
open HEADER,">$outfile.h";
print HEADER "/* Autogenerated file by bitmap.pl */\n\n";
open OUT,">$outfile.cc";
print OUT "/* Autogenerated file by bitmap.pl */\n\n";
while (@ARGV) {
  $file=shift;
	$numPics=shift;
	$numPics=1 unless $numPics;
	print "$_: Not a bitmap.\n" and next unless ($file=~/(.*)\.bmp$/i);
	$name=$1;
	open(BMP, $file);
	binmode BMP;
	read(BMP, $header,54);
	($bm,$bmpOffset,$infoSize,$width,$height,$bpp,$compression)= 
		unpack("a2 x8 VV VV x2 v V x12 V",$header);
	print "$_: Not a bitmap.\n" and next unless ($bm eq "BM");
	print "$_: Old style bitmap.\n" and next unless ($infoSize==40);
	print "$_: Invalid width/height.\n" and next
		unless ($width>=0 && $width<=65535 && $height>=0 && $height<=65535);
	print "$_: Wrong colour depth.\n" and next unless ($bpp==4);
	print "$_: Compressed image.\n" and next unless ($compression==0);

	seek BMP, $bmpOffset,0;
	$bmpScanLen=int((int(($width*$bpp+7)/8)+3)/4)*4;

	@pixelines=();
	for($i=0;$i<$height;$i++) {
		read BMP, $scanline, $bmpScanLen;
		push (@pixelines,[map { (($_>>4)&0xF,$_&0xF) } unpack("C*",$scanline)]);
	}
	@pixelines=reverse @pixelines;
	$picWidth=int($width/$numPics);
	@pics=();
	@masks=();
	$needMask=0;
	for($pic=0;$pic<$numPics;$pic++) {  
		foreach(@pixelines) {
			@pixels=@$_;
			$picVal=$maskVal=0;
			for($i=0;$i<$picWidth;$i++) {
				$val=shift @pixels;
				#$val=-1 unless defined($val);
				$picVal<<=2;
				$maskVal<<=2;
				$newVal=$val==0?0x03:$val==8?0x02:$val==7?0x01:$val==15?0x00:-1;
				if ($newVal!=-1) {
					$picVal|=$newVal;
					$maskVal|=0x3;
				}
				else {
					$needMask=1;
				}
				if ($i%16==15) {
					push(@pics,$picVal);
					push(@masks,$maskVal);
					$maskVal=$picVal=0;
				}        
			}
			if ($picWidth%16!=0)
			{
				push(@pics,$picVal<<(32-($picWidth%16)*2));
				push(@masks,$maskVal<<(32-($picWidth%16)*2));
			}
			$_=[@pixels];
		}
	}
	$blocksPerLine=int(($picWidth+15)/16);
	$arrSize=$height*$blocksPerLine;
	
	print HEADER "#define NUM_\U${name}\E $numPics\n";
	print HEADER "#define \U${name}\E_WIDTH $picWidth\n";
	print HEADER "#define \U${name}\E_HEIGHT $height\n";
	print HEADER "extern unsigned long ${name}_pic[][$arrSize];\n";
	print HEADER "extern unsigned long ${name}_mask[][$arrSize];\n" if ($needMask);
	$xcnt=$ycnt=$pcnt=0;
	print OUT "unsigned long ${name}_pic[][$arrSize]={\n  {\n  ";
	foreach (@pics) {
		printf OUT "%10lu",$_;
		if (++$xcnt==$blocksPerLine) {
			if (++$ycnt==$height) {
				if (++$pcnt==$numPics) {
					print OUT "\n  }\n};\n\n";
				} else {
					print OUT "\n  },{\n  ";
					$ycnt=0;
				}
			} else {
				print OUT ",\n  ";
			}
			$xcnt=0;
		}
		else {
			print OUT ",  ";
		}
	}
	if ($needMask)
	{
		$xcnt=$ycnt=$pcnt=0;
		print OUT "unsigned long ${name}_mask[][$arrSize]={\n  {\n  ";
		foreach (@masks) {
			printf OUT "%10lu",$_;
			if (++$xcnt==$blocksPerLine) {
				if (++$ycnt==$height) {
					if (++$pcnt==$numPics) {
						print OUT "\n  }\n};\n";
					} else {
						print OUT "\n  },{\n  ";
						$ycnt=0;
					}
				} else {
					print OUT ",\n  ";
				}
				$xcnt=0;
			}
			else {
				print OUT ",  ";
			}
		}
	}
}

